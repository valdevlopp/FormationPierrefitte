<html><head><link rel="stylesheet" type="text/css" href="css/book.css"/><link rel="stylesheet" type="text/css" href="css/highlight.css"/><link rel="stylesheet" type="text/css" href="css/console.css"/><link rel="stylesheet" type="text/css" href="css/codemirror.css"/><meta http-equiv="Content-Type" content="text/html; charset=utf-8"/><title>Recherche -- JavaScript Éloquent</title></head><body><script type="text/javascript" src="js/before.js"> </script><div class="content"><script type="text/javascript">var chapterTag = 'search';</script><div class="navigation"><a href="chapter6.html">&lt;&lt; Chapitre précédent</a> | <a href="contents.html">Table des matières</a> | <a href="index.html">Couverture</a> | <a href="chapter8.html">Chapitre suivant &gt;&gt;</a></div><h1><span class="number">Chapitre 7: </span>Recherche</h1><div class="block"><p>Ce chapitre n’introduit pas de nouveaux concepts spécifiques à JavaScript. À la
place, nous allons étudier les solutions de deux problèmes, et discuter de
techniques et d’algorithmes intéressants tout au long du chapitre. Si cela ne
vous semble pas intéressant, il est possible de sauter ce chapitre.</p></div><hr/><div class="block"><p>Laissez-moi introduire notre premier problème. Jetez un coup d’œil à ce plan.
Il montre Hiva Oa, une petite île tropicale de l’océan Pacifique.</p><div class="illustration"><img src="img/Hiva Oa.png"/></div><p>Les lignes grises sont des routes, et les nombres à côté représentent la
longueur de ces routes. Imaginez que l’on ait besoin de connaître le chemin le
plus court pour relier deux endroits sur Hiva Oa. Quelle approche pourrait-on
adopter&nbsp;?</p><p>Non, vraiment, ne lisez pas le paragraphe en diagonale. Essayez de réfléchir
sérieusement aux manières de le faire, et réfléchissez aux problèmes que vous
pourriez rencontrer. Quand vous lisez un livre technique, il est bien trop
facile de parcourir le texte très rapidement, d’acquiescer solennellement et de
s’empresser d’oublier ce que l’on a lu. Si vous faites sérieusement un effort
pour résoudre un problème, il devient votre problème, et sa solution aura
vraiment du sens.</p></div><hr/><div class="block"><p>Le premier aspect de ce problème est, de nouveau, de représenter nos
informations. Les informations contenues dans l’image n’ont pas beaucoup de
sens pour l’ordinateur. On pourrait essayer de coder un programme qui
étudierait l’image et en extrairait des informations… Mais cela pourrait
devenir compliqué. Si on avait vingt mille cartes à interpréter, ce serait une
bonne idée. En l’occurrence, nous nous chargerons de faire l’interprétation
nous-mêmes, et convertirons les données du plan pour qu’elles soient
exploitables en langage informatique.</p><p>Que doit savoir notre programme&nbsp;? Il doit être capable de trouver quel lieux
sont connectés, et quelle distance font les routes qui les relient. Les lieux
et les routes sur l’île forment un <a name="key1"></a>graphe, comme les mathématiciens
l’appellent. Il y a plusieurs possibilités pour enregistrer les graphes. Une
solution simple consiste à enregistrer dans un tableau des objets de type
route, chacun étant doté de propriétés désignant ses deux extrémités et sa
longueur.</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = [{<span class="property">point1</span>: <span class="string">&quot;Point Kiukiu&quot;</span>, <span class="property">point2</span>: <span class="string">&quot;Hanaiapa&quot;</span>, <span class="property">length</span>: <span class="atom">19</span>},
             {<span class="property">point1</span>: <span class="string">&quot;Point Kiukiu&quot;</span>, <span class="property">point2</span>: <span class="string">&quot;Mont Feani&quot;</span>, <span class="property">length</span>: <span class="atom">15</span>}
             <span class="comment">/* et ainsi de suite */</span>];</pre><p>Cependant, il s’avère que lorsque le programme essaiera de déterminer une
route, il aura très souvent besoin de consulter une liste de tous les routes
commençant à un point donné, tout comme une personne qui se situe à un
carrefour aura besoin de regarder les panneaux de direction et lire « Hanaiapa
: 19 km, Mont Feani : 15 km&nbsp;». Ce serait sympa si c’était facile (et rapide) à
faire.</p><p>Avec la représentation donnée au-dessus, nous devons éplucher tous les noms de
route en gardant ceux qui sont utiles chaque fois que nous voulons ces panneaux
de direction. Une meilleure technique serait d’enregistrer cette liste
directement. Par exemple, utiliser un objet qui associe les noms de lieux avec
la liste des panneaux :</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = {<span class="string">&quot;Point Kiukiu&quot;</span>: [{<span class="property">to</span>: <span class="string">&quot;Hanaiapa&quot;</span>, <span class="property">distance</span>: <span class="atom">19</span>},
                              {<span class="property">to</span>: <span class="string">&quot;Mont Feani&quot;</span>, <span class="property">distance</span>: <span class="atom">15</span>},
                              {<span class="property">to</span>: <span class="string">&quot;Taaoa&quot;</span>, <span class="property">distance</span>: <span class="atom">15</span>}],
             <span class="string">&quot;Taaoa&quot;</span>: [<span class="comment">/* et cetera */</span>]};</pre><p>Quand nous avons cet objet, obtenir les routes qui partent du «&nbsp;Point Kiukiu&nbsp;»
revient juste à jeter un œil à <code>routes[&quot;Point Kiukiu&quot;]</code>.</p></div><hr/><div class="block"><p>Toutefois, cette nouvelle représentation contient des données dupliquées : la
route reliant A à B est listée à la fois dans A et dans B. La première
représentation demandait déjà beaucoup de travail pour rentrer les données,
avec celle-là c’est encore pire.</p><p>Heureusement, nous avons à notre disposition le talent de notre ordinateur pour
la répétition des tâches. On peut indiquer les routes une fois, et faire
générer par l’ordinateur la bonne structure de données. D’abord, définissez un
objet initial vide appelé <code>routes</code>, et écrivez une fonction <code>creerRoute</code> :</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = {};
<span class="keyword">function</span> <span class="variable">creerRoute</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>, <span class="variabledef">distance</span>) {
  <span class="keyword">function</span> <span class="variabledef">ajouterRoute</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
    <span class="keyword">if</span> (!(<span class="localvariable">depart</span> in <span class="variable">routes</span>))
      <span class="variable">routes</span>[<span class="localvariable">depart</span>] = [];
    <span class="variable">routes</span>[<span class="localvariable">depart</span>].<span class="property">push</span>({<span class="property">arrivee</span>: <span class="localvariable">arrivee</span>, <span class="property">distance</span>: <span class="localvariable">distance</span>});
  }
  <span class="localvariable">ajouterRoute</span>(<span class="localvariable">depart</span>, <span class="localvariable">arrivee</span>);
  <span class="localvariable">ajouterRoute</span>(<span class="localvariable">arrivee</span>, <span class="localvariable">depart</span>);
}</pre><p>Sympa, n’est-ce pas&nbsp;? Remarquez comment la fonction interne (<code>ajouterRoute</code>)
utilise les mêmes noms (<code>depart</code> et <code>arrivee</code>) pour ses paramètres que ceux de
la fonction externe.  Ils ne vont pas interférer : à l’intérieur de
<code>ajouterRoute</code>, ils correspondent aux paramètre de <code>ajouterRoute</code>, et à
l’extérieur, ils correspondent aux paramètres de <code>creerRoute</code>.</p><p>L’instruction <code>if</code> dans <code>ajouterRoute</code> s’assure qu’il y a un tableau de
destinations associées avec le lieu nommé par <code>depart</code>, et s’il n’y en a pas
encore, il ajoute une entrée vide. De cette façon, à la ligne suivante il peut
supposer que le tableau existe déjà et entrer la nouvelle route dedans.</p><p>Maintenant, les informations de la carte ressemblent à ceci :</p><pre class="code"><span class="variable">creerRoute</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Hanaiapa&quot;</span>, <span class="atom">19</span>);
<span class="variable">creerRoute</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">15</span>);
<span class="variable">creerRoute</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">15</span>);
<span class="comment">// …</span></pre></div><hr/><div class="block"><a name="exercise1"></a><div class="exercisenum">Ex. 7.1</div><div class="exercise"><p>Dans la description ci-dessus, on a encore trois fois l’occurrence de la chaîne
de caractères <code>&quot;Point Kiukiu&quot;</code> à la suite. Nous pourrions générer une
description encore plus succincte en permettant à des routes multiples d’être
définies sur une seule ligne.</p><p>Écrivez une fonction <code>creerRoutes</code> qui accepte un nombre variable d’arguments.
Le premier argument est toujours le point de départ des routes, et chaque paire
d’arguments qui suit donne le point d’arrivée et une distance.</p><p>Ne dupliquez pas la fonctionnalité de <code>creerRoute</code>, mais demandez à
<code>creerRoutes</code> d’appeler <code>creerRoute</code> pour réaliser la véritable création de
route.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">creerRoutes</span>(<span class="variabledef">depart</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">1</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">arguments</span>.<span class="property">length</span>; <span class="localvariable">i</span> += <span class="atom">2</span>)
    <span class="variable">creerRoute</span>(<span class="localvariable">depart</span>, <span class="localvariable">arguments</span>[<span class="localvariable">i</span>], <span class="localvariable">arguments</span>[<span class="localvariable">i</span> + <span class="atom">1</span>]);
}</pre><p>Cette fonction utilise un paramètre nommé, <code>depart</code>, et récupère les autres
paramètres dans le (presque-) tableau <code>arguments</code> . <code>i</code> démarre à <code>1</code> car il
doit ignorer le premier paramètre. <code>i += 2</code> est la simplification de l’équation
<code>i = i + 2</code>, comme vous vous rappelez sans doute.</p><pre class="code"><span class="keyword">var</span> <span class="variable">routes</span> = {};
<span class="variable">creerRoutes</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Hanaiapa&quot;</span>, <span class="atom">19</span>,
          <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">15</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">15</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Airport&quot;</span>, <span class="string">&quot;Hanaiapa&quot;</span>, <span class="atom">6</span>, <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">5</span>,
          <span class="string">&quot;Atuona&quot;</span>, <span class="atom">4</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">11</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Mont Temetiu&quot;</span>, <span class="string">&quot;Mont Feani&quot;</span>, <span class="atom">8</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">4</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Atuona&quot;</span>, <span class="string">&quot;Taaoa&quot;</span>, <span class="atom">3</span>, <span class="string">&quot;Hanakee pearl lodge&quot;</span>, <span class="atom">1</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Cemetery&quot;</span>, <span class="string">&quot;Hanakee pearl lodge&quot;</span>, <span class="atom">6</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">5</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Hanapaoa&quot;</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">3</span>);
<span class="variable">creerRoutes</span>(<span class="string">&quot;Puamua&quot;</span>, <span class="string">&quot;Mont Ootua&quot;</span>, <span class="atom">13</span>, <span class="string">&quot;Point Teohotepapapa&quot;</span>, <span class="atom">14</span>);

<span class="variable">show</span>(<span class="variable">routes</span>[<span class="string">&quot;Airport&quot;</span>]);</pre></div></div><hr/><div class="block"><p>Nous avons réussi à réduire considérablement notre description des informations
sur les routes en définissant quelques opérations pratiques. On pourrait dire
que nous avons exprimé l’information de façon plus succincte en élargissant
notre vocabulaire. <a name="key2"></a>Définir un &quot;petit langage&quot; comme
ceci est une technique très puissante ―&nbsp;quand, à un moment, vous vous
retrouvez à écrire du code répétitif ou redondant, arrêtez-vous et essayez de
réduire ce code avec un vocabulaire qui le raccourcira et le condensera.</p><p>Le code redondant est non seulement ennuyeux à écrire mais aussi
potentiellement générateur d’erreurs. Les gens font moins attention quand ils
font des choses qui ne requiert pas de réflexion de leur part. En plus de cela,
le code répétitif est dur à modifier, parce qu’une structure, qui répète le
même motif un millier de fois, doit également être modifiée un millier de fois
si elle s’avère incorrecte ou suboptimale.</p></div><hr/><div class="block"><p>Si vous exécutez tous les morceaux de code ci-dessus, vous devriez avoir une
variable nommée <code>routes</code> qui contient toutes les routes de l’île. Quand nous
avons besoin de la liste des routes qui partent d’un certain lieu, nous pouvons
juste faire <code>routes[lieu]</code>. Mais si quelqu’un fait une coquille dans le nom
d’un endroit, ce qui est fort probable avec des noms pareils, il récupèrera un
<code>undefined</code> à la place du tableau qu’il attendait, et des erreurs étranges
peuvent survenir. Nous allons donc plutôt utiliser une fonction qui permet de
récupérer les tableaux de routes et qui nous hurle dessus si nous lui donnons
un nom de lieu inconnu :</p><pre class="code"><span class="keyword">function</span> <span class="variable">routesDepuis</span>(<span class="variabledef">lieu</span>) {
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="variable">routes</span>[<span class="localvariable">lieu</span>];
  <span class="keyword">if</span> (<span class="localvariable">trouve</span> == <span class="atom">undefined</span>)
    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="variable">Error</span>(<span class="string">&quot;Auncun lieu nommé '&quot;</span> + <span class="localvariable">lieu</span> + <span class="string">&quot;' n’a été trouvé.&quot;</span>);
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}

<span class="variable">show</span>(<span class="variable">routesDepuis</span>(<span class="string">&quot;Puamua&quot;</span>));</pre></div><hr/><div class="block"><p>Voici un premier jet pour un algorithme de recherche de chemin, la méthode du
joueur :</p><pre class="code"><span class="keyword">function</span> <span class="variable">routeDuJoueur</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">function</span> <span class="variabledef">entierAuHasard</span>(<span class="variabledef">seuil</span>) {
    <span class="keyword">return</span> <span class="variable">Math</span>.<span class="property">floor</span>(<span class="variable">Math</span>.<span class="property">random</span>() * <span class="localvariable">seuil</span>);
  }
  <span class="keyword">function</span> <span class="variabledef">directionAuHasard</span>(<span class="variabledef">depart</span>) {
    <span class="keyword">var</span> <span class="variabledef">options</span> = <span class="variable">routesDepuis</span>(<span class="localvariable">depart</span>);
    <span class="keyword">return</span> <span class="localvariable">options</span>[<span class="localvariable">entierAuHasard</span>(<span class="localvariable">options</span>.<span class="property">length</span>)].<span class="property">arrivee</span>;
  }

  <span class="keyword">var</span> <span class="variabledef">chemin</span> = [];
  <span class="keyword">while</span> (<span class="atom">true</span>) {
    <span class="localvariable">chemin</span>.<span class="property">push</span>(<span class="localvariable">depart</span>);
    <span class="keyword">if</span> (<span class="localvariable">depart</span> == <span class="localvariable">arrivee</span>)
      <span class="keyword">break</span>;
    <span class="localvariable">depart</span> = <span class="localvariable">directionAuHasard</span>(<span class="localvariable">depart</span>);
  }
  <span class="keyword">return</span> <span class="localvariable">chemin</span>;
}

<span class="variable">show</span>(<span class="variable">routeDuJoueur</span>(<span class="string">&quot;Hanaiapa&quot;</span>, <span class="string">&quot;Mont Feani&quot;</span>));</pre><p>À chaque branche de la route, le joueur lance son dé pour décider quelle route
il va prendre. Si le dé le renvoie à son lieu de départ, ainsi soit-il. Tôt ou
tard, il arrivera à destination, du moment que tous les endroits de l’île sont
reliés par des routes.</p><p>La ligne la plus déroutante est surement celle contenant <a name="key3"></a><code>Math.random</code>. Cette
fonction renvoie un nombre pseudo-aléatoire<a class="footref" href="#footnote1">1</a> entre 0 et 1. Essayez de
l’appeler un certain nombre de fois à la console, vous verrez qu’elle vous
donnera (fort probablement) un nombre différent à chaque fois. La fonction
<code>entierAuHasard</code> multiplie ce nombre par l’argument qui lui est donné et
arrondit le résultat au chiffre inférieur avec <code>Math.floor</code>. Ainsi par exemple,
<code>entierAuHasard(3)</code> renverra les chiffres <code>0</code>, <code>1</code> ou <code>2</code>.</p></div><hr/><div class="block"><p>La méthode du joueur est la manière de faire pour ceux qui abhorrent la
structuration et la planification, qui cherchent désespérément l’aventure. Nous
avons décidé d’écrire un programme qui peut trouver le chemin <em>le plus court</em>
pour aller d’un point à un autre, il nous faut donc utiliser une autre méthode.</p><p>Une approche très simple est de résoudre un tel problème par la méthode dite
«&nbsp;<a name="key4"></a>essais et erreurs&nbsp;». Il faut :</p><ol><li>Générer toutes les routes possibles.</li><li>Dans cet ensemble, trouver le plus court chemin qui connecte le point de départ au point d’arrivée.</li></ol><p>L’étape 2 n’est pas difficile. L’étape 1 est un peu plus problématique. Si vous
acceptez des routes avec des boucles, il existe une infinité de routes. Bien
sûr, il est peu probable que les routes avec des boucles soient les chemins les
plus courts pour aller d’un point à un autre, et les routes qui ne commencent
pas au point de départ ne doivent pas non plus être prises en compte. Pour un
petit graphe telle que Hiva Oa, il devrait être possible de générer des routes
non cycliques (exemptes de boucles) démarrant d’un lieu donné.</p></div><hr/><div class="block"><p>Mais d’abord, nous avons besoin de nouveaux outils. Le premier est une fonction
nommée <code>member</code>, qui est utilisée pour déterminer si un élément est présent
dans un tableau. L’itinéraire (que l’on appellera également route par la suite)
sera conservé comme un tableau de noms, et quand le voyageur arrivera à un
nouveau lieu, l’algorithme appellera <code>member</code> pour vérifier si le voyageur est
déjà passé par cet endroit. Cela peut ressembler à ça :</p><pre class="code"><span class="keyword">function</span> <span class="variable">member</span>(<span class="variabledef">tableau</span>, <span class="variabledef">valeur</span>) {
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="atom">false</span>;
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span>(<span class="variabledef">element</span>) {
    <span class="keyword">if</span> (<span class="localvariable">element</span> === <span class="localvariable">valeur</span>)
      <span class="localvariable">trouve</span> = <span class="atom">true</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}

<span class="variable">print</span>(<span class="variable">member</span>([<span class="atom">6</span>, <span class="atom">7</span>, <span class="string">&quot;Bordeaux&quot;</span>], <span class="atom">7</span>));</pre><p>Toutefois, ceci va parcourir la totalité du tableau, même si la valeur est
trouvée immédiatement en première position. Quel gâchis. Quand vous utilisez
une boucle <code>for</code>, vous pouvez en sortir avec l’instruction <code>break</code>, mais dans
une structure <code>forEach</code> ceci ne fonctionnera pas, parce que le cœur de la
boucle est une fonction et l’instruction <code>break</code> n’interrompt pas une fonction.
Une solution pour être d’adapter <code>forEach</code> pour qu’il reconnaisse certains
types d’exceptions comme une un signal pour un arrêt (similaire à <code>break</code> dans
les boucles <code>for</code>)</p><pre class="code"><span class="keyword">var</span> <span class="variable">Break</span> = {<span class="property">toString</span>: <span class="keyword">function</span>() {<span class="keyword">return</span> <span class="string">&quot;Break&quot;</span>;}};

<span class="keyword">function</span> <span class="variable">forEach</span>(<span class="variabledef">tableau</span>, <span class="variabledef">action</span>) {
  <span class="keyword">try</span> {
    <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++)
      <span class="localvariable">action</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
  }
  <span class="keyword">catch</span> (<span class="variabledef">exception</span>) {
    <span class="keyword">if</span> (<span class="localvariable">exception</span> != <span class="variable">Break</span>)
      <span class="keyword">throw</span> <span class="localvariable">exception</span>;
  }
}</pre></div><hr/><div class="block"><p>Maintenant, si la fonction <code>action</code> lance un <code>Break</code>, <code>forEach</code> absorbera
l’exception et interrompra la boucle. L’objet stocké dans la variable <code>Break</code>
est utilisé exclusivement comme un élément de comparaison. La seule raison pour
laquelle je lui ai donné une propriété <code>toString</code> est qu’il pourrait être très
utile de trouver à quelle étrange valeur vous avez à faire si vous finissez par
récupérer une exception <code>Break</code> en-dehors d’un <code>forEach</code>.</p></div><hr/><div class="block"><p>Disposer d’un moyen de sortir de boucles <code>forEach</code> peut être très utile, mais
dans le cas de la fonction <code>member</code> le résultat demeure assez moche, parce que
vous avez besoin de stocker ce résultat particulier et de le retourner plus
tard. Nous pourrions encore ajouter une autre sorte d’exception, <code>Return</code>, à
laquelle on peut attribuer une propriété <code>value</code>, et faire en sorte que
<code>forEach</code> renvoie cette valeur lorsqu’une exception de ce genre est lancée,
mais ce serait vraiment spécifique à notre problème et plutôt confus. Ce dont
nous avons vraiment besoin c’est d’une nouvelle fonction de haut niveau,
appelée <a name="key5"></a><code>any</code> (ou quelquefois <code>some</code>). Elle ressemble à ceci :</p><pre class="code"><span class="keyword">function</span> <span class="variable">any</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++) {
    <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="localvariable">test</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
    <span class="keyword">if</span> (<span class="localvariable">trouve</span>)
      <span class="keyword">return</span> <span class="localvariable">trouve</span>;
  }
  <span class="keyword">return</span> <span class="atom">false</span>;
}

<span class="keyword">function</span> <span class="variable">member</span>(<span class="variabledef">tableau</span>, <span class="variabledef">valeur</span>) {
  <span class="keyword">return</span> <span class="variable">any</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;===&quot;</span>], <span class="localvariable">valeur</span>), <span class="localvariable">tableau</span>);
}

<span class="variable">print</span>(<span class="variable">member</span>([<span class="string">&quot;Peur&quot;</span>, <span class="string">&quot;Répugnance&quot;</span>], <span class="string">&quot;Rejet&quot;</span>));</pre><p><code>any</code> parcourt tous les éléments d’un tableau, de gauche à droite, et les
soumet à une fonction de test. Le premier élément ayant déclenché une réponse
<code>true</code> de la fonction de test est renvoyé. Si aucun élément ne déclenche de
réponse <code>true</code>, elle retourne <code>false</code>. Appeler <code>any(test, tableau)</code> est plus ou
moins équivalent à <code>test(tableau[0]) || test(tableau[1]) || …</code> et cætera.</p></div><hr/><div class="block"><p>Tout comme <code>&amp;&amp;</code> est le pendant de <code>||</code>, <code>any</code> a son pendant, appelé <a name="key6"></a><code>every</code> :</p><pre class="code"><span class="keyword">function</span> <span class="variable">every</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">for</span> (<span class="keyword">var</span> <span class="variabledef">i</span> = <span class="atom">0</span>; <span class="localvariable">i</span> &lt; <span class="localvariable">tableau</span>.<span class="property">length</span>; <span class="localvariable">i</span>++) {
    <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="localvariable">test</span>(<span class="localvariable">tableau</span>[<span class="localvariable">i</span>]);
    <span class="keyword">if</span> (!<span class="localvariable">trouve</span>)
      <span class="keyword">return</span> <span class="localvariable">trouve</span>;
  }
  <span class="keyword">return</span> <span class="atom">true</span>;
}

<span class="variable">show</span>(<span class="variable">every</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;!=&quot;</span>], <span class="atom">0</span>), [<span class="atom">1</span>, <span class="atom">2</span>, -<span class="atom">1</span>]));</pre></div><hr/><div class="block"><p>Une autre fonction dont nous aurons besoin est <code>flatten</code>. Cette fonction prend
un tableau de tableaux et met les éléments des tableaux dans un unique grand
tableau.</p><pre class="code">  <span class="keyword">function</span> <span class="variable">flatten</span>(<span class="variabledef">tableaux</span>) {
    <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
    <span class="variable">forEach</span>(<span class="localvariable">tableaux</span>, <span class="keyword">function</span> (<span class="variabledef">tableau</span>) {
      <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>){<span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">element</span>);});
    });
    <span class="keyword">return</span> <span class="localvariable">resultat</span>;
  }</pre><p>La même chose pourrait être faite en utilisant la méthode <code>concat</code> et un genre
de <code>reduce</code>, mais ceci serait moins efficace. De la même manière, concaténer
ensemble des chaînes de caractères à de nombreuses reprises est plus lent que
les mettre dans un tableau puis appeler la méthode <code>join</code>. Concaténer ensemble
des tableaux de manière répétée produit beaucoup de tableaux intermédiaires et
inutiles.</p></div><hr/><div class="block"><a name="exercise2"></a><div class="exercisenum">Ex. 7.2</div><div class="exercise"><p>Avant de commencer à générer des routes, nous avons besoin d’une fonction
d’ordre supérieur supplémentaire. Celle-ci est appelée <a name="key7"></a><code>filter</code>. Tout comme
<code>map</code>, elle prend une fonction et un tableau en arguments, et produit un
nouveau tableau, mais au lieu de placer les résultats des appels à la fonction
dans le nouveau tableau, elle produit un tableau avec seulement les valeurs de
l’ancien tableau pour lequel la fonction donnée retourne <code>true</code> (ou une valeur
considérée équivalente a <code>true</code>). Écrivez cette fonction.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">filter</span>(<span class="variabledef">test</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">var</span> <span class="variabledef">resultat</span> = [];
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span> (<span class="variabledef">element</span>) {
    <span class="keyword">if</span> (<span class="localvariable">test</span>(<span class="localvariable">element</span>))
      <span class="localvariable">resultat</span>.<span class="property">push</span>(<span class="localvariable">element</span>);
  });
  <span class="keyword">return</span> <span class="localvariable">resultat</span>;
}

<span class="variable">show</span>(<span class="variable">filter</span>(<span class="variable">partial</span>(<span class="variable">op</span>[<span class="string">&quot;&gt;&quot;</span>], <span class="atom">5</span>), [<span class="atom">0</span>, <span class="atom">4</span>, <span class="atom">8</span>, <span class="atom">12</span>]));</pre><p>(Si le résultat de cette utilisation de <code>filter</code> vous surprend, souvenez-vous
que l’argument donné à <code>partial</code> est utilisé comme le <em>premier</em> argument de la
fonction, de manière à ce qu’il se retrouve à la gauche de <code>&gt;</code>.)</p></div></div><hr/><div class="block"><p>Imaginez à quoi un algorithme permettant de générer des itinéraires pourrait
ressembler ―&nbsp;il commence au point de départ et génère un itinéraire pour
chaque route qui quitte ce lieu. À la fin de chaque route, il continue à
générer des itinéraires supplémentaires. Il ne parcourt pas un simple
itinéraire, il se ramifie. À cause de cela, la <a name="key8"></a>récursion est une manière
normale de modéliser cet algorithme.</p><pre class="code"><span class="keyword">function</span> <span class="variable">itinerairesPossibles</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">function</span> <span class="variabledef">trouverItineraires</span>(<span class="variabledef">itineraire</span>) {
    <span class="keyword">function</span> <span class="variabledef">pasParcouru</span>(<span class="variabledef">route</span>) {
      <span class="keyword">return</span> !<span class="variable">member</span>(<span class="localvariable">itineraire</span>.<span class="property">lieux</span>, <span class="localvariable">route</span>.<span class="property">arrivee</span>);
    }
    <span class="keyword">function</span> <span class="variabledef">continueItineraire</span>(<span class="variabledef">route</span>) {
      <span class="keyword">return</span> <span class="localvariable">trouverItineraires</span>({<span class="property">lieux</span>: <span class="localvariable">itineraire</span>.<span class="property">lieux</span>.<span class="property">concat</span>([<span class="localvariable">route</span>.<span class="property">arrivee</span>]),
                         <span class="property">length</span>: <span class="localvariable">itineraire</span>.<span class="property">length</span> + <span class="localvariable">route</span>.<span class="property">distance</span>});
    }

    <span class="keyword">var</span> <span class="variabledef">fin</span> = <span class="localvariable">itineraire</span>.<span class="property">lieux</span>[<span class="localvariable">itineraire</span>.<span class="property">lieux</span>.<span class="property">length</span> - <span class="atom">1</span>];
    <span class="keyword">if</span> (<span class="localvariable">fin</span> == <span class="localvariable">arrivee</span>)
      <span class="keyword">return</span> [<span class="localvariable">itineraire</span>];
    <span class="keyword">else</span>
      <span class="keyword">return</span> <span class="variable">flatten</span>(<span class="variable">map</span>(<span class="localvariable">continueItineraire</span>, <span class="variable">filter</span>(<span class="localvariable">pasParcouru</span>,
                                               <span class="variable">routesDepuis</span>(<span class="localvariable">fin</span>))));
  }
  <span class="keyword">return</span> <span class="localvariable">trouverItineraires</span>({<span class="property">lieux</span>: [<span class="localvariable">depart</span>], <span class="property">length</span>: <span class="atom">0</span>});
}

<span class="variable">show</span>(<span class="variable">itinerairesPossibles</span>(<span class="string">&quot;Point Teohotepapapa&quot;</span>, <span class="string">&quot;Point Kiukiu&quot;</span>).<span class="property">length</span>);
<span class="variable">show</span>(<span class="variable">itinerairesPossibles</span>(<span class="string">&quot;Hanapaoa&quot;</span>, <span class="string">&quot;Mont Ootua&quot;</span>));</pre><p>La fonction renvoie un tableau d’objets itinéraire, chacun contenant un tableau
de lieux parcourus par l’itinéraire et une longueur. <code>trouverItineraires</code>
continue un itinéraire récursivement, renvoyant un tableau avec toutes les
extensions possibles de cette route. Quand la fin de l’itinéraire est le lieu
défini comme lieu de fin, il retourne juste l’itinéraire, sachant que continuer
l’itinéraire serait absurde. Si c’est un autre lieu, il faut donc continuer. La
ligne contenant <code>flatten</code>/<code>map</code>/<code>filter</code> est probablement la plus dure à
appréhender. Voilà ce qu’elle dit : «&nbsp;Prends toutes les routes partant de ce
lieu, en te débarrassant de celles qui vont à des endroits que nous avons déjà
visités. Continue chacune de ces routes, ce qui donnera pour chacune d’entre
elles un tableau d’itinéraires finis, puis mets toutes ces routes dans un grand
tableau renvoyé en résultat&nbsp;».</p><p>Cette ligne fait beaucoup de choses. C’est en cela que les bonnes abstractions
sont utiles : elles vous permettent de dire des choses compliquées sans taper
des écrans entiers de code.</p><p>Ceci ne risque-t-il pas de se répéter indéfiniment, en continuant à s’appeler
lui-même (via <code>continueItineraire</code>)&nbsp;? Non, à un certain moment, toutes les
routes iront à des lieux déjà traversés par l’itinéraire, et le résultat de
<code>filter</code> sera un tableau vide. Cartographier un tableau vide renvoie un tableau
vide, l’écraser renvoie également un tableau vide. Donc appeler
<code>trouverItineraires</code> dans une impasse entraîne un tableau vide, qui signifie «
il n’y a aucun moyen de continuer cet itinéraire&nbsp;».</p><p>Veuillez noter que les lieux sont ajoutés à des itinéraires en utilisant
<a name="key9"></a><code>concat</code> et non <a name="key10"></a><code>push</code>. La méthode <code>concat</code> crée un nouveau tableau, alors
que <code>push</code> modifie le tableau existant. Comme cette fonction risque de faire
bifurquer divers itinéraires à partir d’une seule portion de route, il ne faut
pas modifier le tableau qui représente l’itinéraire original, parce qu’il doit
être utilisé plusieurs fois.</p></div><hr/><div class="block"><a name="exercise3"></a><div class="exercisenum">Ex. 7.3</div><div class="exercise"><p>Maintenant que nous avons tous les itinéraires possibles, essayons de trouver
le plus court. Écrivez une fonction <code>itineraireLePlusCourt</code> qui, tout comme
<code>itinerairesPossibles</code>, prend les noms des lieux de début et de fin en
arguments. Elle retournera un simple objet itinéraire, du même type que ce que
<code>itinerairesPossibles</code> produit.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">itineraireLePlusCourt</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">var</span> <span class="variabledef">itineraireLePlusCourtTrouve</span> = <span class="atom">null</span>;
  <span class="variable">forEach</span>(<span class="variable">itinerairesPossibles</span>(<span class="localvariable">depart</span>, <span class="localvariable">arrivee</span>), <span class="keyword">function</span>(<span class="variabledef">itineraire</span>) {
    <span class="keyword">if</span> (!<span class="localvariable">itineraireLePlusCourtTrouve</span> || <span class="localvariable">itineraireLePlusCourtTrouve</span>.<span class="property">length</span> &gt; <span class="localvariable">itineraire</span>.<span class="property">length</span>)
      <span class="localvariable">itineraireLePlusCourtTrouve</span> = <span class="localvariable">itineraire</span>;
  });
  <span class="keyword">return</span> <span class="localvariable">itineraireLePlusCourtTrouve</span>;
}</pre><p>Le point épineux dans les algorithmes de «&nbsp;minimisation&nbsp;» ou de «&nbsp;maximisation
» est qu’il ne faut pas tout massacrer quand un tableau vide est passé à un tel
algorithme.  Dans notre cas, on sait qu’il y aura au moins une route entre 2
lieux donnés, donc nous pouvons simplement ignorer ce problème. Mais ce
raisonnement est un peu léger. Que faire si la route entre Puamua et le Mont
Ootua, qui est escarpée et boueuse, est emportée par une pluie torrentielle ?
Ce serait dommage que cela engendre une erreur dans notre fonction, donc il
faut que la fonction renvoie une valeur <code>null</code> quand aucun itinéraire n’est
trouvé.</p><p>Voici donc une approche très &quot;programmation fonctionnelle&quot;, aussi abstraite que
possible :</p><pre class="code"><span class="keyword">function</span> <span class="variable">minimise</span>(<span class="variabledef">func</span>, <span class="variabledef">tableau</span>) {
  <span class="keyword">var</span> <span class="variabledef">plusPetitScore</span> = <span class="atom">null</span>;
  <span class="keyword">var</span> <span class="variabledef">trouve</span> = <span class="atom">null</span>;
  <span class="variable">forEach</span>(<span class="localvariable">tableau</span>, <span class="keyword">function</span>(<span class="variabledef">element</span>) {
    <span class="keyword">var</span> <span class="variabledef">score</span> = <span class="localvariable">func</span>(<span class="localvariable">element</span>);
    <span class="keyword">if</span> (<span class="localvariable">plusPetitScore</span> == <span class="atom">null</span> || <span class="localvariable">score</span> &lt; <span class="localvariable">plusPetitScore</span>) {
      <span class="localvariable">plusPetitScore</span> = <span class="localvariable">score</span>;
      <span class="localvariable">trouve</span> = <span class="localvariable">element</span>;
    }
  });
  <span class="keyword">return</span> <span class="localvariable">trouve</span>;
}

<span class="keyword">function</span> <span class="variable">getProperty</span>(<span class="variabledef">nomDePropriete</span>) {
  <span class="keyword">return</span> <span class="keyword">function</span>(<span class="variabledef">objet</span>) {
    <span class="keyword">return</span> <span class="localvariable">objet</span>[<span class="localvariable">nomDePropriete</span>];
  };
}

<span class="keyword">function</span> <span class="variable">itineraireLePlusCourt</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">return</span> <span class="variable">minimise</span>(<span class="variable">getProperty</span>(<span class="string">&quot;length&quot;</span>), <span class="variable">itinerairesPossibles</span>(<span class="localvariable">depart</span>, <span class="localvariable">arrivee</span>));
}</pre><p>Malheureusement, cette version est trois fois plus longue que l’autre. Dans les
programmes où vous voulez minimiser un certain nombre de choses, il peut être
intéressant d’écrire un algorithme générique comme celui-ci, que vous pourrez
réutiliser. Dans la plupart des cas, la première version suffira.</p><p>Notez toutefois la fonction <a name="key11"></a><code>getProperty</code>, elle est souvent utile quand on
fait de la programmation fonctionnelle avec des objets.</p></div></div><hr/><div class="block"><p>Voyons à quel trajet aboutit notre algorithme entre la pointe Kiukiu et la
pointe Teohotepapapa…</p><pre class="code"><span class="variable">show</span>(<span class="variable">itineraireLePlusCourt</span>(<span class="string">&quot;Point Kiukiu&quot;</span>, <span class="string">&quot;Point Teohotepapapa&quot;</span>).<span class="property">lieux</span>);</pre></div><hr/><div class="block"><p>Sur une petite île comme Hiva Oa, ce n’est pas une tâche insurmontable de
générer tous les itinéraires possibles. Si vous essayez de faire ça sur une
carte raisonnablement détaillée de la Belgique, par exemple, cela va prendre un
temps ridiculement long, sans parler d’une quantité de mémoire démentielle.
Pourtant, vous avez sans doute déjà vu de tels planificateurs d’itinéraires en
ligne. Ils vous indiquent un trajet plus ou moins idéal parmi un énorme
labyrinthe de routes possibles en quelques secondes à peine. Comment font-ils
ça&nbsp;?</p><p>Si vous êtes attentif, vous avez peut-être remarqué qu’il n’est pas nécessaire
de générer tous les itinéraires jusqu’au bout. Si nous comparons les
itinéraires <em>pendant</em> que nous les élaborons, nous pouvons éviter de calculer
un ensemble volumineux d’itinéraire, dès que nous avons trouvé un premier
itinéraire pour notre destination, nous pouvons cesser l’extension des autres
itinéraires plus longs que celui-ci.</p></div><hr/><div class="block"><p>Pour essayer, nous utiliserons une grille de 20 sur 20 en guise de carte :</p><div class="illustration"><img src="img/height.png"/></div><p>Ce que vous voyez là est une carte en relief d’un terrain montagneux. Les
points jaunes représentent les pics, et les zones bleues, les vallées. La zone
est divisée en carrés de 100 mètres de côté. Nous disposons d’une fonction
<code>altitudeEn</code>, qui peut nous donner l’altitude en mètres, de n’importe quel
carré de cette carte, dans laquelle les carrés sont représentés par des objets
avec des propriétés <code>x</code> et <code>y</code>.</p><pre class="code"><span class="variable">print</span>(<span class="variable">altitudeEn</span>({<span class="property">x</span>: <span class="atom">0</span>, <span class="property">y</span>: <span class="atom">0</span>}));
<span class="variable">print</span>(<span class="variable">altitudeEn</span>({<span class="property">x</span>: <span class="atom">11</span>, <span class="property">y</span>: <span class="atom">18</span>}));</pre></div><hr/><div class="block"><p>Nous voulons traverser ce territoire à pied, en partant en haut à gauche pour
arriver en bas à droite. Une grille peut être assimilée à un graphe. Chaque
carré est un nœud connecté aux carrés qui l’entourent.</p><p>Nous n’aimons pas gaspiller l’énergie, donc nous préférons prendre le chemin le
plus facile. Monter est plus pénible que descendre, et descendre plus pénible
que marcher sur un terrain plat<a class="footref" href="#footnote2">2</a>. Cette fonction calcule le «&nbsp;dénivelé&nbsp;» entre
deux carrés adjacents, qui représente l’intensité de la fatigue que vous
éprouvez à marcher ou grimper de l’un à l’autre. On considère que monter est
deux fois plus pénible que descendre.</p><pre class="code"><span class="keyword">function</span> <span class="variable">distancePonderee</span>(<span class="variabledef">pointA</span>, <span class="variabledef">pointB</span>) {
  <span class="keyword">var</span> <span class="variabledef">differenceHauteur</span> = <span class="variable">altitudeEn</span>(<span class="localvariable">pointB</span>) - <span class="variable">altitudeEn</span>(<span class="localvariable">pointA</span>);
  <span class="keyword">var</span> <span class="variabledef">facteurElevation</span> = (<span class="localvariable">differenceHauteur</span> &lt; <span class="atom">0</span> ? <span class="atom">1</span> : <span class="atom">2</span>);
  <span class="keyword">var</span> <span class="variabledef">distanceaPlat</span> = (<span class="localvariable">pointA</span>.<span class="property">x</span> == <span class="localvariable">pointB</span>.<span class="property">x</span> || <span class="localvariable">pointA</span>.<span class="property">y</span> == <span class="localvariable">pointB</span>.<span class="property">y</span> ? <span class="atom">100</span> : <span class="atom">141</span>);
  <span class="keyword">return</span> <span class="localvariable">distanceaPlat</span> + <span class="localvariable">facteurElevation</span> * <span class="variable">Math</span>.<span class="property">abs</span>(<span class="localvariable">differenceHauteur</span>);
}</pre><p>Notez le calcul de <code>distanceaPlat</code>. Si les deux points sont sur la même ligne
ou colonne, ils sont contigus, et la distance qui les sépare est cent mètres.
Sinon, on considère qu’ils sont adjacents en diagonale, et la distance en
diagonale entre deux carrés de cette taille est cent fois la racine carrée de
deux, ce qui fait à peu près <code>141</code>. Cette fonction ne doit pas être appelée
pour des carrés qui sont éloignés de plus d’une unité (elle pourrait faire une
double vérification … mais elle est trop paresseuse).</p></div><hr/><div class="block"><p>Les points sur la carte sont représentés par des objets contenant des
propriétés <code>x</code> et <code>y</code>. Ces trois fonctions sont utiles quand on travaille sur
de tels objets :</p><pre class="code"><span class="keyword">function</span> <span class="variable">point</span>(<span class="variabledef">x</span>, <span class="variabledef">y</span>) {
  <span class="keyword">return</span> {<span class="property">x</span>: <span class="localvariable">x</span>, <span class="property">y</span>: <span class="localvariable">y</span>};
}

<span class="keyword">function</span> <span class="variable">ajouterPoints</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="variable">point</span>(<span class="localvariable">a</span>.<span class="property">x</span> + <span class="localvariable">b</span>.<span class="property">x</span>, <span class="localvariable">a</span>.<span class="property">y</span> + <span class="localvariable">b</span>.<span class="property">y</span>);
}

<span class="keyword">function</span> <span class="variable">pointsIdentiques</span>(<span class="variabledef">a</span>, <span class="variabledef">b</span>) {
  <span class="keyword">return</span> <span class="localvariable">a</span>.<span class="property">x</span> == <span class="localvariable">b</span>.<span class="property">x</span> &amp;&amp; <span class="localvariable">a</span>.<span class="property">y</span> == <span class="localvariable">b</span>.<span class="property">y</span>;
}

<span class="variable">show</span>(<span class="variable">pointsIdentiques</span>(<span class="variable">ajouterPoints</span>(<span class="variable">point</span>(<span class="atom">10</span>, <span class="atom">10</span>), <span class="variable">point</span>(<span class="atom">4</span>, -<span class="atom">2</span>)),
               <span class="variable">point</span>(<span class="atom">14</span>, <span class="atom">8</span>)));</pre></div><hr/><div class="block"><a name="exercise4"></a><div class="exercisenum">Ex. 7.4</div><div class="exercise"><p>Si nous nous mettons à chercher des trajets sur cette carte, nous aurons encore
besoin de créer des «&nbsp;panneaux&nbsp;», des listes de directions que l’on peut
prendre à un point donné. Écrivez une fonction <code>directionsPossible</code> qui prend
un objet point comme argument et renvoie un tableau des points qui
l’environnent. Nous pouvons nous déplacer seulement vers des points adjacents,
à la fois en ligne droite et en diagonale, si bien que les carrés ont au
maximum huit carrés voisins. Prenez garde à ne pas renvoyer des carrés qui se
trouveraient en-dehors de la carte. Pour autant qu’on sache, le bord de la
carte pourrait bien être le bord du monde.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">directionsPossible</span>(<span class="variabledef">depart</span>) {
  <span class="keyword">var</span> <span class="variabledef">dimensionCarte</span> = <span class="atom">20</span>;
  <span class="keyword">function</span> <span class="variabledef">dansLaCarte</span>(<span class="variabledef">point</span>) {
    <span class="keyword">return</span> <span class="localvariable">point</span>.<span class="property">x</span> &gt;= <span class="atom">0</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">x</span> &lt; <span class="localvariable">dimensionCarte</span> &amp;&amp;
           <span class="localvariable">point</span>.<span class="property">y</span> &gt;= <span class="atom">0</span> &amp;&amp; <span class="localvariable">point</span>.<span class="property">y</span> &lt; <span class="localvariable">dimensionCarte</span>;
  }

  <span class="keyword">var</span> <span class="variabledef">directions</span> = [<span class="variable">point</span>(-<span class="atom">1</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">1</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">0</span>, -<span class="atom">1</span>),
                    <span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">1</span>), <span class="variable">point</span>(-<span class="atom">1</span>, -<span class="atom">1</span>), <span class="variable">point</span>(-<span class="atom">1</span>, <span class="atom">1</span>),
                    <span class="variable">point</span>(<span class="atom">1</span>, <span class="atom">1</span>), <span class="variable">point</span>(<span class="atom">1</span>, -<span class="atom">1</span>)];
  <span class="keyword">return</span> <span class="variable">filter</span>(<span class="localvariable">dansLaCarte</span>, <span class="variable">map</span>(<span class="variable">partial</span>(<span class="variable">ajouterPoints</span>, <span class="localvariable">depart</span>),
                               <span class="localvariable">directions</span>));
}

<span class="variable">show</span>(<span class="variable">directionsPossible</span>(<span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">0</span>)));</pre><p>J’ai créé une variable <code>dimensionCarte</code>, dans le seul but de ne pas avoir à
écrire deux fois <code>20</code>. Si, à un autre moment, nous voulons utiliser la même
fonction pour une autre carte, ce serait laborieux avec un code farci de <code>20</code>,
qu’il faudrait tous remplacer un à un. Nous pourrions même aller jusqu’à
utiliser <code>dimensionCarte</code> comme argument de <code>directionsPossible</code>, pour pouvoir
utiliser la fonction pour différentes cartes sans les modifier. J’ai estimé que
ce n’était pas nécessaire dans ce cas, de telles choses peuvent toujours être
modifiées quand le besoin s’en fait sentir.</p><p>Alors, pourquoi n’ai-je pas ajouté une variable pour stocker <code>0</code>, qui apparaît
également à plusieurs reprises&nbsp;? J’ai fait comme si les cartes commençaient
toujours à <code>0</code>, donc il est peu probable que cela change, et utiliser une
variable pour cela ne fait qu’ajouter du bruit.</p></div></div><hr/><div class="block"><p>Pour trouver une route sur cette carte sans que notre navigateur n’interrompe
le programme parce qu’il prend trop de temps à se terminer, nous devons arrêter
de faire de l’amateurisme et mettre en œuvre un algorithme sérieux. Beaucoup de
travail a été consacré à de tels problèmes dans le passé, et beaucoup de
solutions ont été conçues (certaines brillantes, d’autres inutiles). Une
solution très populaire et efficace est nommé <a name="key12"></a>A* (prononcé A étoile). Nous
allons consacrer le reste de ce chapitre à intégrer une fonction de recherche
d’itinéraire A* pour notre carte.</p><p>Avant que je me penche sur l’algorithme en lui-même, laissez-moi vous en dire
un peu plus sur le problème qu’il résout. Le problème avec la recherche de
routes par l’intermédiaire de graphes, c’est que dans les grands graphes, il y
a énormément de routes. Notre chercheur de route Hiva Oa nous a montré que
quand le graphe est petit, tout ce que l’on avait besoin de faire c’était de
s’assurer que nos itinéraires ne repassaient pas par des points où ils étaient
déjà passés. Sur notre nouvelle carte, ceci ne suffit plus.</p><p>Le problème fondamental, c’est qu’il y a trop de possibilités pour aller dans
la mauvaise direction. À moins de savoir comment nous diriger vers la
destination pendant l’exploration des chemins, un choix que nous faisons pour
poursuivre une route donnée va plus probablement nous faire emprunter le
mauvais chemin plutôt que le bon. Si vous continuez à générer des itinéraires
de cette façon, et même si l’un d’entre eux atteint la cible de manière
accidentelle, vous ne savez pas si c’est le chemin le plus court.</p><p>Donc ce que vous voulez faire, c’est explorer les directions susceptibles de
vous amener à la destination finale en premier. Sur une grille comme sur une
carte, vous pouvez avoir une petite estimation de l’optimisation d’un tracé en
vérifiant sa longueur et la proximité de sa destination avec la cible. En
ajoutant sa longueur à l’estimation de la distance restante, vous pouvez vous
faire une bonne idée des itinéraires qui sont prometteurs. Si vous prolongez
les itinéraires prometteurs en premier, vous avez moins de risques de perdre du
temps avec ceux qui sont inutiles.</p></div><hr/><div class="block"><p>Mais cela ne suffit pas encore. Si notre carte était celle d’un monde
parfaitement plat, le chemin qui semble prometteur serait presque toujours le
meilleur, et nous pourrions utiliser la méthode ci-dessus pour nous rendre
directement au but. Mais nous avons des vallées et des collines sur notre
chemin, donc il est difficile de prédire à l’avance quel itinéraire sera le
plus direct. À cause de cela, nous finissons toujours pas explorer beaucoup
trop de possibilités différentes.</p><p>Pour y remédier, nous pouvons tirer parti du fait que nous recherchons sans
arrêt l’itinéraire le plus prometteur. Une fois que l’on a déterminé que le
chemin A est le meilleur moyen de se rendre au point X, nous pouvons nous en
souvenir. Quand plus tard le chemin B se rend aussi au point X, nous savons que
ce n’est pas la meilleure route, donc nous n’avons pas à faire plus de
recherches dessus. Ceci peut éviter à notre programme de calculer beaucoup
d’itinéraires inutiles.</p></div><hr/><div class="block"><p>Donc, l’algorithme ressemble à quelque chose comme ça :</p><p>Il y a deux ensembles de données pour garder un historique. Le premier est
appelé la liste ouverte, elle contient des itinéraires partiels qui doivent
toujours être explorés. Chaque chemin a une note, qui est calculée en
additionnant sa longueur à la distance estimée qui sépare du but. Cette
estimation doit toujours être optimiste, elle ne doit jamais exagérer la
longueur. Le second est un ensemble de nœuds que nous avons parcourus, avec
l’itinéraire partiel qui nous y a amené. Celui-ci, nous l’appellerons la liste
des nœuds atteints. On commence en ajoutant à la liste ouverte un itinéraire
qui contient uniquement le nœud de départ et on l’enregistre dans la liste des
nœuds atteints.</p><p>Puis, tant qu’il y a des nœuds dans la liste ouverte, nous prenons celui qui a
le plus petit score (donc le meilleur), et nous trouvons les directions dans
lesquelles il peut continuer (en appelant <code>directionsPossible</code>). Pour chaque
nœud obtenu en retour, nous créons un nouveau chemin en le rattachant à notre
route initiale et en ajustant la longueur du chemin par l’intermédiaire de
<code>distancePonderee</code>. L’extrémité de chacun de ces itinéraires est ensuite
recherchée dans la liste des nœuds atteints.</p><p>Si le nœud n’est pas dans la liste des nœuds atteints, cela veut dire que nous
ne l’avons pas encore rencontré avant, nous ajoutons le nouveau chemin à la
liste ouverte, et nous l’enregistrons dans la liste des nœuds parcourus. Si
nous l’<em>avons</em> vu avant, nous comparons la note du nouvel itinéraire aux notes
des autres itinéraires de la liste des nœuds parcourus. Si le nouveau chemin
est plus court, on remplace la route existante avec la nouvelle. Autrement, on
se débarrasse du nouvel itinéraire puisque on a déjà une manière plus rapide de
se rendre à ce point.</p><p>On continue ainsi jusqu’à ce que l’itinéraire que nous sortons de la liste des
nœuds parcourus atteigne le nœud correspondant au but ultime, auquel cas nous
avons trouvé notre itinéraire, ou jusqu’à ce que la liste des nœuds parcourus
soit vide, auquel cas nous nous sommes rendus compte qu’il n’y a pas de route.
Dans notre cas, la carte ne contient pas d’obstacles insurmontables, donc il y
a toujours un chemin.</p><p>Comment savons-nous que le premier itinéraire complet que nous obtenons de la
liste des nœuds parcourus est le plus direct&nbsp;? C’est la conséquence du fait que
nous nous intéressons seulement à un chemin quand il fait le score le plus bas.
Le score d’un itinéraire est sa longueur actuelle additionnée d’un estimation
<em>optimiste</em> de sa longueur restante. Cela veut dire que si un itinéraire
obtient la note la plus basse dans la liste ouverte, c’est toujours le chemin
le plus direct vers sa destination finale, il est impossible qu’un autre
itinéraire puisse trouver plus tard une meilleure route vers ce point, car si
elle était meilleure, son score aurait été plus bas.</p></div><hr/><div class="block"><p>Essayez de ne pas vous énerver lorsque les subtilités de ce fonctionnement vous
échappent. Quand on réfléchit à des algorithmes tels que ceux-là, avoir vu
avant «&nbsp;quelque chose qui y ressemble&nbsp;» aide beaucoup, cela vous donne un point
de repère pour comparer les approches. Les programmeurs débutants doivent faire
sans de tels points de repères, ce qui peut les amener facilement à s’égarer.
Ayez simplement conscience que ce travail est d’un niveau assez avancé, faites
une lecture globale du reste du chapitre, et revenez-y plus tard quand vous
vous sentirez de taille à relever le défi.</p></div><hr/><div class="block"><p>Je suis désolé de vous l’annoncer, mais pour une partie de l’algorithme, je
vais encore devoir invoquer la magie. La liste ouverte nécessite de pouvoir
disposer d’une grande quantité de routes, et de trouver rapidement celle qui
fait le plus petit score. Les enregistrer dans un tableau normal et parcourir
ce tableau chaque fois est beaucoup trop lent, je vous donne donc une structure
de données appelée <a name="key13"></a>tas binaire. Vous les créez avec <code>new</code>, tout comme les
objets <code>Date</code>, en leur donnant une fonction qui est utilisée pour «&nbsp;donner un
score&nbsp;» aux éléments passés en argument. L’objet résultant possède les méthodes
<code>push</code> et <code>pop</code>, tout comme un tableau, mais <code>pop</code> donne toujours l’élément
avec le plus petit score, au lieu de donner celui qui a été ajouté (avec la
méthode <code>push</code>) en dernier.</p><pre class="code"><span class="keyword">function</span> <span class="variable">identity</span>(<span class="variabledef">x</span>) {
  <span class="keyword">return</span> <span class="localvariable">x</span>;
}

<span class="keyword">var</span> <span class="variable">tasBinaire</span> = <span class="keyword">new</span> <span class="variable">BinaryHeap</span>(<span class="variable">identity</span>);
<span class="variable">forEach</span>([<span class="atom">2</span>, <span class="atom">4</span>, <span class="atom">5</span>, <span class="atom">1</span>, <span class="atom">6</span>, <span class="atom">3</span>], <span class="keyword">function</span>(<span class="variabledef">nombre</span>) {
  <span class="variable">tasBinaire</span>.<span class="property">push</span>(<span class="localvariable">nombre</span>);
});
<span class="keyword">while</span> (<span class="variable">tasBinaire</span>.<span class="property">size</span>() &gt; <span class="atom">0</span>)
  <span class="variable">show</span>(<span class="variable">tasBinaire</span>.<span class="property">pop</span>());</pre><p>L’<a href="appendix2.html">appendice 2</a> traite de l’implémentation de la structure de données, ce qui
est assez intéressant. Après avoir lu le <a href="chapter8.html">chapitre 8</a>, vous pourriez vouloir jeter un
œil dessus.</p></div><hr/><div class="block"><p>Les nécessités de l’optimisation peuvent avoir un autre effet. L’algorithme
d’Hiva Oa utilisait des tableaux de destination pour enregistrer les routes, et
copiait celles-ci avec la méthode <code>concat</code> quand il allongeait ces routes.
Cette fois, nous ne pouvons pas nous permettre de copier des tableaux puisque
nous explorerons des tonnes de chemins. Nous allons donc plutôt utiliser une «
chaîne&nbsp;» d’objets pour stocker une route. Chaque objet dans la chaîne possède
des propriétés, notamment la position sur la carte et la longueur de la route
déjà effectuée, mais garde également en mémoire une propriété qui pointe vers
l’objet précédent de la chaîne. Ça donne quelque chose comme ça :</p><div class="illustration"><img src="img/objectchain.png"/></div><p>Les cercles couleur cyan sont les objet utiles, et les lignes sont les
propriétés. L’objet <code>A</code> est le début de la route ici. L’objet <code>B</code> est utilisé
pour construire un nouveau tracé qui se prolonge après <code>A</code>. Quand on doit plus
tard reconstruire une route, on peut se reposer sur ces propriétés pour trouver
tous les points par où la route est passée. On remarque que l’objet <code>B</code>
appartient à deux routes, une qui se termine en <code>D</code>, et une autre qui se
termine en <code>E</code>. Quand il y a beaucoup de routes, cela peut nous faire
économiser beaucoup d’espace mémoire, chaque nouvelle route nécessite seulement
un nouvel objet pour elle-même, le reste est partagé avec les autres routes qui
ont commencé de la même manière.</p></div><hr/><div class="block"><a name="exercise5"></a><div class="exercisenum">Ex. 7.5</div><div class="exercise"><p>Écrivez une fonction <code>distanceEstimee</code> qui donne une estimation optimiste de la
distance séparant deux emplacements. Elle n’a pas besoin de s’intéresser aux
données d’altitude, mais peut supposer que le terrain est plat. Rappelez-vous
que l’on se déplace seulement tout droit et en diagonale, et que l’on compte
les déplacements en diagonale entre deux carrés comme valant <code>141</code>.</p></div><div class="solution"><pre class="code"><span class="keyword">function</span> <span class="variable">distanceEstimee</span>(<span class="variabledef">pointA</span>, <span class="variabledef">pointB</span>) {
  <span class="keyword">var</span> <span class="variabledef">dx</span> = <span class="variable">Math</span>.<span class="property">abs</span>(<span class="localvariable">pointA</span>.<span class="property">x</span> - <span class="localvariable">pointB</span>.<span class="property">x</span>),
      <span class="variabledef">dy</span> = <span class="variable">Math</span>.<span class="property">abs</span>(<span class="localvariable">pointA</span>.<span class="property">y</span> - <span class="localvariable">pointB</span>.<span class="property">y</span>);
  <span class="keyword">if</span> (<span class="localvariable">dx</span> &gt; <span class="localvariable">dy</span>)
    <span class="keyword">return</span> (<span class="localvariable">dx</span> - <span class="localvariable">dy</span>) * <span class="atom">100</span> + <span class="localvariable">dy</span> * <span class="atom">141</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> (<span class="localvariable">dy</span> - <span class="localvariable">dx</span>) * <span class="atom">100</span> + <span class="localvariable">dx</span> * <span class="atom">141</span>;
}</pre><p>Ces formules étranges sont utilisées pour décomposer le trajet en une partie
rectiligne et une partie en diagonale. Si vous avec un trajet tel que
celui-là :</p><div class="illustration"><img src="img/diagonalpath.png"/></div><p>… le chemin fait <code>6</code> cases de larges et <code>4</code> de haut, donc vous avez <code>6 - 3 = 3</code>
déplacements rectilignes et <code>3</code> déplacements en diagonales.</p><p>Si vous écriviez une fonction qui calcule la distance «&nbsp;pythagoricienne&nbsp;»
directe entre ces points, cela fonctionnerait aussi. Nous avons besoin d’une
estimation optimiste, et supposer que nous pouvons aller tout droit vers notre
but est certainement optimiste. Quoi qu’il en soit, plus notre estimation est
correcte, moins notre programme essaiera des itinéraires inutiles.</p></div></div><hr/><div class="block"><a name="exercise6"></a><div class="exercisenum">Ex. 7.6</div><div class="exercise"><p>Nous allons utiliser un tas binaire pour stocker la liste ouverte. Quelle
structure serait la bonne pour la liste des nœuds atteints&nbsp;? Cette liste sera
utilisée pour chercher des routes, en lui passant un couple <code>x</code>, <code>y</code> de
coordonnées. Rapidement de préférence. Écrivez trois fonctions
<code>creerListePointsParcourus</code>, <code>stockerPointsParcourus</code>, et
<code>trouverPointsParcourus</code>. La première crée la structure de données&nbsp;; la
seconde, étant donné une liste de nœuds atteints, un point, et une route,
stocke cette route; la dernière, étant donné une liste de nœuds atteints et un
point, retourne une route ou <code>undefined</code> pour indiquer qu’aucune route n’a été
trouvée pour ce point.</p></div><div class="solution"><p>Une idée raisonnable serait d’utiliser un objet avec des objets à l’intérieur.
Une des coordonnées des points, par exemple <code>x</code>, est utilisé comme nom de
propriété pour l’objet extérieur, et l’autre, <code>y</code>, pour l’objet intérieur. Cela
va nécessiter un peu de tenue de compte pour gérer le fait que, parfois,
l’objet intérieur que nous recherchons n’existe pas (encore).</p><pre class="code"><span class="keyword">function</span> <span class="variable">creerListePointsParcourus</span>() {
  <span class="keyword">return</span> {};
}

<span class="keyword">function</span> <span class="variable">stockerPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>, <span class="variabledef">itineraire</span>) {
  <span class="keyword">var</span> <span class="variabledef">listeInterne</span> = <span class="localvariable">liste</span>[<span class="localvariable">point</span>.<span class="property">x</span>];
  <span class="keyword">if</span> (<span class="localvariable">listeInterne</span> == <span class="atom">undefined</span>) {
    <span class="localvariable">listeInterne</span> = {};
    <span class="localvariable">liste</span>[<span class="localvariable">point</span>.<span class="property">x</span>] = <span class="localvariable">listeInterne</span>;
  }
  <span class="localvariable">listeInterne</span>[<span class="localvariable">point</span>.<span class="property">y</span>] = <span class="localvariable">itineraire</span>;
}

<span class="keyword">function</span> <span class="variable">trouverPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>) {
  <span class="keyword">var</span> <span class="variabledef">listeInterne</span> = <span class="localvariable">liste</span>[<span class="localvariable">point</span>.<span class="property">x</span>];
  <span class="keyword">if</span> (<span class="localvariable">listeInterne</span> == <span class="atom">undefined</span>)
    <span class="keyword">return</span> <span class="atom">undefined</span>;
  <span class="keyword">else</span>
    <span class="keyword">return</span> <span class="localvariable">listeInterne</span>[<span class="localvariable">point</span>.<span class="property">y</span>];
}</pre><p>Une autre possibilité est de fusionner les <code>x</code> et <code>y</code> du point en un nom unique
de propriété, et de l’utiliser pour stocker les itinéraires dans un objet
unique.</p><pre class="code"><span class="keyword">function</span> <span class="variable">pointID</span>(<span class="variabledef">point</span>) {
  <span class="keyword">return</span> <span class="localvariable">point</span>.<span class="property">x</span> + <span class="string">&quot;-&quot;</span> + <span class="localvariable">point</span>.<span class="property">y</span>;
}

<span class="keyword">function</span> <span class="variable">creerListePointsParcourus</span>() {
  <span class="keyword">return</span> {};
}

<span class="keyword">function</span> <span class="variable">stockerPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>, <span class="variabledef">itineraire</span>) {
  <span class="localvariable">liste</span>[<span class="variable">pointID</span>(<span class="localvariable">point</span>)] = <span class="localvariable">itineraire</span>;
}

<span class="keyword">function</span> <span class="variable">trouverPointsParcourus</span>(<span class="variabledef">liste</span>, <span class="variabledef">point</span>) {
  <span class="keyword">return</span> <span class="localvariable">liste</span>[<span class="variable">pointID</span>(<span class="localvariable">point</span>)];
}</pre></div></div><hr/><div class="block"><p><a name="key14"></a> Définir un type de structure donné en fournissant un ensemble
de fonctions pour créer et manipuler de telles structures est une technique
utile. Cela permet «&nbsp;d’isoler&nbsp;» le code qui utilise la structure, des détails
de la structure elle-même. Remarquez que, peu importe laquelle des deux
implémentations ci-dessus est utilisée, le code qui a besoin d’une liste des
nœuds atteints fonctionne exactement de la même façon. Il ne se préoccupe pas
du type d’objet utilisé, tant qu’il reçoit le résultat qu’il attend.</p><p>On discutera plus en détail de cela au <a href="chapter8.html">chapitre 8</a>, où nous apprendrons à faire des
types d’objet comme <code>BinaryHeap</code> (tas binaire), qui sont créés en utilisant
<code>new</code> et qui ont des méthodes pour les manipuler.</p></div><hr/><div class="block"><p>Nous avons donc enfin notre vraie fonction de recherche de chemin :</p><pre class="code"><span class="keyword">function</span> <span class="variable">trouverItineraire</span>(<span class="variabledef">depart</span>, <span class="variabledef">arrivee</span>) {
  <span class="keyword">var</span> <span class="variabledef">listeOuverte</span> = <span class="keyword">new</span> <span class="variable">BinaryHeap</span>(<span class="variable">scoreItineraire</span>);
  <span class="keyword">var</span> <span class="variabledef">pointsParcourus</span> = <span class="variable">creerListePointsParcourus</span>();

  <span class="keyword">function</span> <span class="variabledef">scoreItineraire</span>(<span class="variabledef">itineraire</span>) {
    <span class="keyword">if</span> (<span class="localvariable">itineraire</span>.<span class="property">score</span> == <span class="atom">undefined</span>)
      <span class="localvariable">itineraire</span>.<span class="property">score</span> = <span class="variable">distanceEstimee</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">arrivee</span>) +
                    <span class="localvariable">itineraire</span>.<span class="property">longueur</span>;
    <span class="keyword">return</span> <span class="localvariable">itineraire</span>.<span class="property">score</span>;
  }
  <span class="keyword">function</span> <span class="variabledef">ajouterItineraireOuvert</span>(<span class="variabledef">itineraire</span>) {
    <span class="localvariable">listeOuverte</span>.<span class="property">push</span>(<span class="localvariable">itineraire</span>);
    <span class="variable">stockerPointsParcourus</span>(<span class="localvariable">pointsParcourus</span>, <span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">itineraire</span>);
  }
  <span class="localvariable">ajouterItineraireOuvert</span>({<span class="property">point</span>: <span class="localvariable">depart</span>, <span class="property">longueur</span>: <span class="atom">0</span>});

  <span class="keyword">while</span> (<span class="localvariable">listeOuverte</span>.<span class="property">size</span>() &gt; <span class="atom">0</span>) {
    <span class="keyword">var</span> <span class="variabledef">itineraire</span> = <span class="localvariable">listeOuverte</span>.<span class="property">pop</span>();
    <span class="keyword">if</span> (<span class="variable">pointsIdentiques</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">arrivee</span>))
      <span class="keyword">return</span> <span class="localvariable">itineraire</span>;

    <span class="variable">forEach</span>(<span class="variable">directionsPossible</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>), <span class="keyword">function</span>(<span class="variabledef">direction</span>) {
      <span class="keyword">var</span> <span class="variabledef">itineraireConnu</span> = <span class="variable">trouverPointsParcourus</span>(<span class="localvariable">pointsParcourus</span>, <span class="localvariable">direction</span>);
      <span class="keyword">var</span> <span class="variabledef">nouvelleLongueur</span> = <span class="localvariable">itineraire</span>.<span class="property">longueur</span> +
                      <span class="variable">distancePonderee</span>(<span class="localvariable">itineraire</span>.<span class="property">point</span>, <span class="localvariable">direction</span>);
      <span class="keyword">if</span> (!<span class="localvariable">itineraireConnu</span> || <span class="localvariable">itineraireConnu</span>.<span class="property">longueur</span> &gt; <span class="localvariable">nouvelleLongueur</span>){
        <span class="keyword">if</span> (<span class="localvariable">itineraireConnu</span>)
          <span class="localvariable">listeOuverte</span>.<span class="property">remove</span>(<span class="localvariable">itineraireConnu</span>);
        <span class="localvariable">ajouterItineraireOuvert</span>({<span class="property">point</span>: <span class="localvariable">direction</span>,
                      <span class="property">from</span>: <span class="localvariable">itineraire</span>,
                      <span class="property">longueur</span>: <span class="localvariable">nouvelleLongueur</span>});
      }
    });
  }
  <span class="keyword">return</span> <span class="atom">null</span>;
}</pre><p>Premièrement, il crée les structures de données dont il a besoin : une liste
ouverte et une liste des nœuds atteints. <code>scoreItineraire</code> est la fonction de
calcul de score passée au tas binaire. Remarquez comment il stocke ses
résultats dans l’objet route, pour éviter d’avoir à le recalculer plusieurs fois.</p><p><code>ajouterItineraireOuvert</code> est une fonction commode pour ajouter une nouvelle
route à la fois à la liste ouverte et à la liste des nœuds atteints. On
l’utilise immédiatement pour ajouter le début de la route. Remarquez que les
objets route ont toujours une propriétés <code>point</code>, qui stocke le point d’arrivée
de la route, et <code>longueur</code>, qui stocke la longueur courante de la route. Les
routes qui ont plus d’une case de longueur, ont aussi une propriété <code>depart</code>,
qui pointe sur leurs prédécesseurs.</p><p>La boucle <code>while</code>, comme décrit dans l’algorithme, prend constamment la route
de plus faible score dans la liste ouverte et vérifie si cela nous mène au but.
Si ce n’est pas le cas, on doit continuer en l’étendant. C’est ce dont s’occupe
<code>forEach</code>. Il cherche si ce nouveau point est dans la liste des nœuds atteints.
S’il ne le trouve pas, ou si le nœud trouvé a une route plus longue que la
nouvelle route, un nouveau objet route est créé et ajouté à la liste ouverte et
la liste des nœuds atteints, et la route existante (s’il y en a une) est
supprimée de la liste ouverte.</p><p>Que se passe-t-il si la route dans <code>itineraireConnu</code> n’est pas dans la liste
ouverte&nbsp;? Cela peut arriver, car les routes ne sont supprimés de la liste
ouverte que lorsqu’on a déterminé qu’elles étaient la route optimale pour
atteindre leur destination. Si nous essayons de supprimer du tas binaire une
valeur qui n’y est pas, cela va lever une exception, donc si mon raisonnement
est faux, nous verrons probablement une exception au moment d’exécuter la
fonction.</p><p>Quand le code devient suffisamment complexe pour vous faire douter de certaines
choses à son propos, c’est une bonne idée d’ajouter quelques vérifications qui
lèvent une exception quand quelque chose se passe mal. De cette façon, vous
savez qu’il ne se passe rien de bizarre «&nbsp;silencieusement&nbsp;», et quand vous
cassez quelque chose, vous saurez immédiatement ce que vous avez cassé.</p></div><hr/><div class="block"><p>Remarquez que cet algorithme n’utilise pas la récursion, mais réussit tout de
même à explorer toutes les branches. La liste ouverte remplace plus ou moins le
rôle qu’avait la pile d’appel de fonction dans la solution récursive du
problème Hiva Oa : il garde une trace des chemins qui doivent encore être
parcourus. Chaque algorithme récursif peut être réécrit d’une façon
non-récursive et utilisant une structure de données qui stocke les «&nbsp;choses
encore à faire&nbsp;».</p></div><hr/><div class="block"><p>Bien, essayons notre recherche de route :</p><pre class="code"><span class="keyword">var</span> <span class="variable">route</span> = <span class="variable">trouverItineraire</span>(<span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">19</span>, <span class="atom">19</span>));</pre><p>Si vous avez exécuté tout le code depuis le début du chapitre, et que vous
n’avez pas introduit d’erreurs, cet appel, même si cela peut prendre quelques
secondes à s’exécuter, devrait vous donner un objet <code>route</code>. Cet objet est
plutôt difficile à lire. On peut le faire en utilisant la fonction <code>showRoute</code>
qui, si votre console est assez grande, vous montrera une route sur une carte.</p><pre class="code"><span class="variable">showRoute</span>(<span class="variable">route</span>);</pre><p>Vous pouvez également passer plusieurs routes à <code>showRoute</code>, ce qui peut être
utile si, par exemple, vous voulez planifier un itinéraire touristique, qui
doit inclure le magnifique point de vue en <code>11</code>, <code>17</code>.</p><pre class="code"><span class="variable">showRoute</span>(<span class="variable">trouverItineraire</span>(<span class="variable">point</span>(<span class="atom">0</span>, <span class="atom">0</span>), <span class="variable">point</span>(<span class="atom">11</span>, <span class="atom">17</span>)),
          <span class="variable">trouverItineraire</span>(<span class="variable">point</span>(<span class="atom">11</span>, <span class="atom">17</span>), <span class="variable">point</span>(<span class="atom">19</span>, <span class="atom">19</span>)));</pre></div><hr/><div class="block"><p>Les variations sur le thème <a name="key15"></a>«&nbsp;chercher un itinéraire optimal dans
un graphe&nbsp;» peuvent être appliquées à de nombreux problèmes, dont beaucoup ne
sont pas liés au fait de trouver un chemin physique. Par exemple, un programme
qui résout le problème de faire rentrer un nombre donné de blocs dans un espace
limité, peut être résolu en explorant les différents &quot;chemins&quot; possibles qu’il
obtient en essayant de positionner un certain bloc à une certaine place. Les
chemins se terminant avec un manque de place pour les derniers blocs sont des
culs-de-sac, et le chemin qui permet de faire rentrer tous les blocs dans
l’espace est la solution.</p></div><ol class="footnotes"><li><a name="footnote1"></a>Les ordinateurs sont des machines déterministes : elles réagissent tout le
temps de la même manière aux données qu’elles reçoivent, et ne peuvent pas
produire de réelles valeurs aléatoires. Par conséquent, nous devons nous
accommoder d’une série de nombres qui semblent aléatoires, mais qui dans les
faits sont le résultat de quelques calculs complexes et déterministes.</li><li><a name="footnote2"></a>Si si, je vous assure.</li></ol><div class="navigation"><a href="chapter6.html">&lt;&lt; Chapitre précédent</a> | <a href="contents.html">Table des matières</a> | <a href="index.html">Couverture</a> | <a href="chapter8.html">Chapitre suivant &gt;&gt;</a></div><div class="footer">© <a href="mailto:marijnh@gmail.com">Marijn Haverbeke</a> et <a href="contributors.html">contributeurs</a> (<a href="http://creativecommons.org/licenses/by/3.0/deed.fr">licence</a>), écrit entre mars et juillet 2007, dernière modification le 3 mai 2015.</div></div><script type="text/javascript" src="js/mochi.js"> </script><script type="text/javascript" src="js/codemirror.js"> </script><script type="text/javascript" src="js/ejs.js"> </script></body></html>